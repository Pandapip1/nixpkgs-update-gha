# SPDX-License-Identifier: WTFPL
name: nixpkgs-update GitHub Action

# Needed by detsys nix installer and magic nix cache
permissions:
  contents: read
  id-token: write

on:
  workflow_dispatch:
  schedule:
    - cron: '0 6 * * *'

env:
  # Don't touch these unless you know what you're doing
  CACHE_KEY: nixpkgs-cache-v1
  NIXPKGS_LOCATION: ~/.cache/nixpkgs
  UPSTREAM_REPO_URL: https://github.com/NixOS/nixpkgs.git

  # Set this to e.g. "SomeOtherRepo/nixpkgs" if you're using a different repository name other than <login>/nixpkgs
  REPO_URL: ""

jobs:
  update-package:
    runs-on: ubuntu-latest
    needs:
      - get-github-info
      - prepare-nixpkgs-cache
    if: needs.get-github-info.outputs.is_template_repo == 'false'
    strategy:
      fail-fast: false
      matrix:
        package:
          # Add your packages here, by attrpath, e.g: python3Packages.yourpackage
          - 

    steps:
      - if: ${{ !matrix.package }}
        run: exit 1

      - name: Restore nixpkgs cache
        uses: actions/cache@v4
        with:
          path: ${{ env.NIXPKGS_LOCATION }}
          key: ${{ env.CACHE_KEY }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v18
        with:
          diagnostic-endpoint: "" # Disable the telemetry by default. If you want to opt-in, just remove this line.

      - name: Magic Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@v12
        with:
          diagnostic-endpoint: "" # Disable the telemetry by default. If you want to opt-in, just remove this line.
          use-flakehub: false

      - name: Get Package Data
        id: pkgdata
        shell: bash
        run: |
          set -euxo pipefail

          export UPDATE_NIX_NAME
          UPDATE_NIX_NAME="$(nix eval --impure --expr "with import $NIXPKGS_LOCATION {}; lib.getName ${{ matrix.package }}" | tr -d '"')"
          export UPDATE_NIX_PNAME
          UPDATE_NIX_PNAME="$(nix eval --impure --expr "with import $NIXPKGS_LOCATION {}; ${{ matrix.package }}.pname" | tr -d '"')"
          export UPDATE_NIX_OLD_VERSION
          UPDATE_NIX_OLD_VERSION="$(nix eval --impure --expr "with import $NIXPKGS_LOCATION {}; lib.getVersion ${{ matrix.package }}" | tr -d '"')"
          export UPDATE_NIX_ATTR_PATH
          UPDATE_NIX_ATTR_PATH="${{ matrix.package }}"
          
          export UPDATE_SCRIPT
          UPDATE_SCRIPT="$(nix eval --impure --expr '(import <nixpkgs/lib>).concatStringsSep " " (import <nixpkgs> { }).python3Packages.optree.updateScript' | tr -d '"')"
          # TODO: This requires a bunch of stuff from master to be in the binary cache
          nix develop --impure --expr "import $NIXPKGS_LOCATION/maintainers/scripts/update.nix" --argstr path ${{ matrix.package }} --argstr skip-prompt true --argstr commit false
          export UPDATE_NIX_NEW_VERSION
          UPDATE_NIX_NEW_VERSION="$(nix eval --impure --expr "with import $NIXPKGS_LOCATION {}; lib.getVersion ${{ matrix.package }}" | tr -d '"')"

          echo "old_version=$UPDATE_NIX_OLD_VERSION" >> "$GITHUB_OUTPUT"
          echo "new_version=$UPDATE_NIX_NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: nixpkgs-update
        shell: bash
        run: |
          nix develop .#nixpkgs-update-gha --command nixpkgs-update \
            --pr \
            --cve \
            --nixpkgs-review \
            "${{ matrix.package }} ${{ steps.pkgdata.outputs.old_version }} ${{ steps.pkgdata.outputs.new_version }}" \
            --nixpkgs-path ~/.cache/nixpkgs
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}

  get-github-info:
    runs-on: ubuntu-latest
    outputs:
      user_login: ${{ steps.extract.outputs.user_login }}
      user_name: ${{ steps.extract.outputs.user_name }}
      user_email: ${{ steps.extract.outputs.user_email }}
      repo_url: ${{ steps.extract.outputs.repo_url }}
      origin_branch: ${{ steps.extract.outputs.origin_branch }}
      is_template_repo: ${{ steps.extract.outputs.is_template_repo }}
      template_url: ${{ steps.extract.outputs.template_url }}
      template_branch: ${{ steps.extract.outputs.template_branch }}
      template_full_name: ${{ steps.extract.outputs.template_full_name }}
    steps:
      - name: Get information from GitHub API
        id: extract
        shell: bash
        run: |
          set -euxo pipefail

          if [ -z "${GITHUB_TOKEN:-""}" ]; then
            echo "::error file=README.md,title=No PAT Configured::A PAT has not been added to this repository's secrets. Please follow the directions in the README file at the root of this repository."
            exit 1
          fi

          USER_INFO="$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user)"
          EMAIL_INFO="$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user/emails)"
          REPO_INFO="$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO_STUB")"

          LOGIN="${LOGIN:-$(echo "$USER_INFO" | jq -r .login)}"
          NAME="${NAME:-$(echo "$USER_INFO" | jq -r .name)}"
          EMAIL="${EMAIL:-$(echo "$EMAIL_INFO" | jq -r '.[] | select(.primary and .verified) | .email // empty')}"
          EMAIL="${EMAIL:-"${LOGIN}@users.noreply.github.com"}"
          REPO_URL="${REPO_URL:-"https://github.com/$LOGIN/nixpkgs.git"}"
          ORIGIN_DEFAULT_BRANCH="$(echo "$REPO_INFO" | jq -r '.default_branch')"
          TEMPLATE_URL=$(echo "$REPO_INFO" | jq -r '.template_repository.clone_url // empty')

          if [ -z "$TEMPLATE_URL" ]; then
            IS_TEMPLATE_REPO="true"
            TEMPLATE_DEFAULT_BRANCH="_"
            TEMPLATE_FULL_NAME="_"
          else
            IS_TEMPLATE_REPO="false"
            TEMPLATE_DEFAULT_BRANCH="$(echo "$REPO_INFO" | jq -r '.template_repository.default_branch')"
            TEMPLATE_FULL_NAME="$(echo "$REPO_INFO" | jq -r '.template_repository.full_name')"
          fi

          {
            echo "user_login=$LOGIN"
            echo "user_name=$NAME"
            echo "user_email=$EMAIL"
            echo "repo_url=$REPO_URL"
            echo "origin_branch=$ORIGIN_DEFAULT_BRANCH"
            echo "is_template_repo=$IS_TEMPLATE_REPO"
            echo "template_url=$TEMPLATE_URL"
            echo "template_branch=$TEMPLATE_DEFAULT_BRANCH"
            echo "template_full_name=$TEMPLATE_FULL_NAME"
          } >> "$GITHUB_OUTPUT"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          REPO_STUB: ${{ github.repository }}

  prepare-nixpkgs-cache:
    runs-on: ubuntu-latest
    needs:
      - get-github-info
    if: needs.get-github-info.outputs.is_template_repo == 'false'
    steps:
      - name: Restore nixpkgs cache
        id: cache
        uses: actions/cache@v4
        with:
          path: ${{ env.NIXPKGS_LOCATION }}
          key: ${{ env.CACHE_KEY }}

      - name: Update nixpkgs
        shell: bash
        run: |
          set -euxo pipefail

          git config --global gc.auto false

          mkdir -p "$(dirname "$NIXPKGS_LOCATION")"
          if [ ! -d "$NIXPKGS_LOCATION" ]; then
            git clone "$REPO_URL" "$NIXPKGS_LOCATION"
            git -C "$NIXPKGS_LOCATION" remote add upstream "$UPSTREAM_REPO_URL" || git -C "$NIXPKGS_LOCATION" remote set-url upstream "$UPSTREAM_REPO_URL"
          fi
          git -C "$NIXPKGS_LOCATION" fetch upstream
          git -C "$NIXPKGS_LOCATION" reset --hard upstream/master

          # Like git gc --aggressive but reuses some existing data at the cost of an insignificant amount of space
          git -C "$NIXPKGS_LOCATION" repack -adf --depth=50 --window=100
          git -C "$NIXPKGS_LOCATION" reflog expire --expire=now --all
          git -C "$NIXPKGS_LOCATION" prune --expire=now
        env:
          REPO_URL: ${{ needs.get-github-info.outputs.repo_url }}

      - name: Save nixpkgs cache
        uses: actions/cache/save@v4
        with:
          path: ${{ env.NIXPKGS_LOCATION }}
          key: ${{ env.CACHE_KEY }}

  rebase-on-template:
    runs-on: ubuntu-latest
    needs:
      - get-github-info
    if: needs.get-github-info.outputs.is_template_repo == 'false'
    steps:
      - name: Rebase on template repo
        shell: bash
        run: |
          set -euxo pipefail

          git config --global advice.defaultBranchName false
          git config --global advice.detachedHead false
          git config --global user.name "$USER_NAME"
          git config --global user.email "$USER_EMAIL"

          AUTH_CRED="${USER_LOGIN}:${GITHUB_TOKEN}@"
          # shellcheck disable=SC2001 # sed is safer here
          AUTHED_ORIGIN_URL="$(echo "$ORIGIN_URL" | sed -E "s#^[a-zA-Z]+://#https://$AUTH_CRED#")"
          # shellcheck disable=SC2001 # sed is safer here
          AUTHED_TEMPLATE_URL="$(echo "$TEMPLATE_URL" | sed -E "s#^[a-zA-Z]+://#https://$AUTH_CRED#")"

          cd "$(mktemp -d)"

          git init

          git remote add origin "$AUTHED_ORIGIN_URL" || git remote set-url template "$AUTHED_ORIGIN_URL"
          git fetch origin

          git remote add template "$AUTHED_TEMPLATE_URL" || git remote set-url template "$AUTHED_TEMPLATE_URL"
          git fetch template

          if [ "$(git merge-base "origin/$ORIGIN_BRANCH" "template/$TEMPLATE_BRANCH")" != "$(git rev-parse "template/$TEMPLATE_BRANCH")" ]; then
            git checkout "origin/$ORIGIN_BRANCH"
            git rebase "template/$TEMPLATE_BRANCH"
            git push --force origin "$ORIGIN_BRANCH"
          fi
        env:
          USER_NAME: ${{ needs.get-github-info.outputs.user_name }}
          USER_EMAIL: ${{ needs.get-github-info.outputs.user_email }}
          USER_LOGIN: ${{ needs.get-github-info.outputs.user_login }}
          ORIGIN_URL: https://github.com/${{ github.repository }}.git
          ORIGIN_BRANCH: ${{ needs.get-github-info.outputs.origin_branch }}
          TEMPLATE_URL: ${{ needs.get-github-info.outputs.template_url }}
          TEMPLATE_BRANCH: ${{ needs.get-github-info.outputs.template_branch }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
